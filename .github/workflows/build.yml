name: Build EqualizerAPO

on:
  push:
    branches: [ main, SIMD_CI ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  actions: write
  packages: write
  artifact-metadata: write

env:
  SOLUTION_FILE: EqualizerAPO.sln
  BUILD_CONFIGURATION: Release

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        name: [
          windows-x64-avx2,
          windows-x64-avx512,
          windows-x64-avx10_1,
          windows-arm64
        ]
        include:
          - name: windows-x64-avx2
            os: windows-2025
            platform: x64
            simd_variant: avx2
            arch_flag: AdvancedVectorExtensions2
            fftw_artifact: fftw-windows-release-x64-avx2
            muparserx_artifact: muparserx-msvc-release-x64-avx2
            libsndfile_artifact: libsndfile-x64-avx2
            msvcdevplatform: x64
          - name: windows-x64-avx512
            os: windows-2025
            platform: x64
            simd_variant: avx512
            arch_flag: AdvancedVectorExtensions512
            fftw_artifact: fftw-windows-release-x64-avx512
            muparserx_artifact: muparserx-msvc-release-x64-avx512
            libsndfile_artifact: libsndfile-x64-avx512
            msvcdevplatform: x64
          - name: windows-x64-avx10_1
            os: windows-2025
            platform: x64
            simd_variant: avx10_1
            arch_flag: AdvancedVectorExtensions101
            fftw_artifact: fftw-windows-release-x64-avx10
            muparserx_artifact: muparserx-msvc-release-x64-avx10
            libsndfile_artifact: libsndfile-x64-avx10
            msvcdevplatform: x64
          - name: windows-arm64
            os: windows-11-arm
            platform: ARM64
            simd_variant: neon
            fftw_artifact: fftw-windows-release-arm64
            muparserx_artifact: muparserx-msvc-release-ARM64
            libsndfile_artifact: libsndfile-arm64
            msvcdevplatform: x86_arm64 

    runs-on: ${{ matrix.os }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Add MSBuild to PATH
      uses: microsoft/setup-msbuild@v2
      with:
        msbuild-architecture: ${{ matrix.platform }}

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2

    # Download FFTW from amd-fftw repository artifacts
    - name: Download FFTW artifacts
      uses: dawidd6/action-download-artifact@v3
      with:
        github_token: ${{ secrets.GH_PAT }}
        workflow: c-cpp.yml
        repo: TheFireKahuna/amd-fftw
        name: ${{ matrix.fftw_artifact }}
        path: ${{ github.workspace }}\deps\fftw
        check_artifacts: true
        search_artifacts: true
        workflow_conclusion: success
        allow_forks: true

    # Download muParserX from repository artifacts
    - name: Download muParserX artifacts
      uses: dawidd6/action-download-artifact@v3
      with:
        github_token: ${{ secrets.GH_PAT }}
        workflow: c-cpp.yml
        repo: TheFireKahuna/muparserx
        name: ${{ matrix.muparserx_artifact }}
        path: ${{ github.workspace }}\deps\muparserx
        check_artifacts: true
        search_artifacts: true
        workflow_conclusion: success
        allow_forks: true

    # Download muParserX from repository artifacts
    - name: Download libsndfile artifacts
      uses: dawidd6/action-download-artifact@v3
      with:
        github_token: ${{ secrets.GH_PAT }}
        workflow: action.yml
        repo: TheFireKahuna/libsndfile
        name: ${{ matrix.libsndfile_artifact }}
        path: ${{ github.workspace }}\deps\libsndfile
        check_artifacts: true
        search_artifacts: true
        workflow_conclusion: success
        allow_forks: true

    # Clone tclap repository (header-only library)
    - name: Download TCLAP
      uses: actions/checkout@v4
      with:
        repository: TheFireKahuna/tclap
        token: ${{ secrets.GITHUB_TOKEN }}
        path: deps/tclap

    # Setup dependency structures
    - name: Setup dependency structures
      shell: pwsh
      run: |
        $depsPath = "${{ github.workspace }}\deps"
        Write-Host "=== Creating Dependency Structures ==="

        # Check FFTW structure
        Write-Host "`nFFTW structure:"
        if (Test-Path "$depsPath\fftw") {
          Get-ChildItem "$depsPath\fftw" -Recurse | Select-Object FullName
        } else {
          Write-Warning "FFTW directory not found"
        }

        # Check muParserX structure
        Write-Host "`nmuParserX structure:"
        if (Test-Path "$depsPath\muparserx") {
          Get-ChildItem "$depsPath\muparserx" -Recurse | Select-Object FullName
        } else {
          Write-Warning "muParserX directory not found"
        }

        # Check libsndfile structure
        Write-Host "`nlibsndfile structure:"
        if (Test-Path "$depsPath\libsndfile") {
          Get-ChildItem "$depsPath\libsndfile" -Recurse | Select-Object FullName
        } else {
          Write-Warning "libsndfile directory not found"
        }

        # Check TCLAP structure
        Write-Host "`nTCLAP structure:"
        if (Test-Path "$depsPath\tclap") {
          Get-ChildItem "$depsPath\tclap" -Recurse -Depth 1 | Select-Object FullName
        } else {
          Write-Warning "TCLAP directory not found"
        }

        Write-Host "=== Locating dependency files ==="

        # Find actual locations of critical files
        $fftwHeader = Get-ChildItem -Path "$depsPath\fftw\Include" -Recurse -Filter "fftw3.h" -ErrorAction SilentlyContinue | Select-Object -First 1
        $fftwLib = Get-ChildItem -Path "$depsPath\fftw\Release" -Recurse -Filter "libfftw3.lib" -ErrorAction SilentlyContinue | Select-Object -First 1
        $mpxLib = Get-ChildItem -Path "$depsPath\muparserx\build\Release" -Recurse -Filter "muparserx.lib" -ErrorAction SilentlyContinue | Select-Object -First 1

        # Set environment variables pointing to actual locations
        if ($fftwHeader) {
          $fftwInclude = $fftwHeader.Directory.FullName
          echo "FFTW_INCLUDE=$fftwInclude" >> $env:GITHUB_ENV
          Write-Host "FFTW_INCLUDE=$fftwInclude"
        } else {
          Write-Error "fftw3.h not found"
          exit 1
        }

        if ($fftwLib) {
          $fftwLibPath = $fftwLib.Directory.FullName
          echo "FFTW_LIB=$fftwLibPath" >> $env:GITHUB_ENV
          Write-Host "FFTW_LIB=$fftwLibPath"
        } else {
          Write-Error "libfftw3.lib not found"
          exit 1
        }

        if (Test-Path  "$depsPath\muparserx") {
          echo "MUPARSERX_INCLUDE=$depsPath\muparserx\parser" >> $env:GITHUB_ENV
          Write-Host "MUPARSERX_INCLUDE=$depsPath\muparserx\parser"
        } else {
          Write-Error "muparserx folder not found"
          exit 1
        }

        if ($mpxLib) {
          $mpxLibPath = $mpxLib.Directory.FullName
          echo "MUPARSERX_LIB=$mpxLibPath" >> $env:GITHUB_ENV
          Write-Host "MUPARSERX_LIB=$mpxLibPath"
        } else {
          Write-Error "muparserx.lib not found"
          exit 1
        }

        # Set root paths for libsndfile and tclap (still used by projects)
        echo "LIBSNDFILE_INCLUDE=$depsPath\libsndfile\include" >> $env:GITHUB_ENV
        echo "LIBSNDFILE_LIB=$depsPath\libsndfile\build\Release" >> $env:GITHUB_ENV
        echo "TCLAP_ROOT=$depsPath\tclap" >> $env:GITHUB_ENV

        Write-Host "`nAll dependency paths configured successfully"

    # Install Qt for Editor, DeviceSelector, and UpdateChecker
    - name: Install Qt
      uses: jurplel/install-qt-action@v4
      with:
        version: '6.10.1'
        host: ${{ matrix.platform == 'ARM64' && 'windows_arm64' || 'windows' }}
        target: 'desktop'
        arch: ${{ matrix.platform == 'ARM64' && 'win64_msvc2022_arm64' || 'win64_msvc2022_64' }}
        dir: '${{ github.workspace }}\Qt'
        install-deps: 'true'
        set-env: 'true'
        setup-python: 'false'
        extra: '--external 7z'

    # Build the solution (excluding Qt VS Tools projects which will be built separately)
    - name: Build solution
      shell: pwsh
      run: |
        # Build main projects (excluding DeviceSelector and UpdateChecker which use Qt VS Tools)
        # Qt VS Tools projects need special handling for CI environments

        Write-Host "Building Common, EqualizerAPO, Benchmark, VoicemeeterClient..."

        $projects = @(
          "Common.vcxproj",
          "EqualizerAPO\EqualizerAPO.vcxproj",
          "Benchmark\Benchmark.vcxproj",
          "VoicemeeterClient\VoicemeeterClient.vcxproj"
        )

        # Set LIB environment variable so linker can find our libraries
        # The linker searches directories in the LIB environment variable
        $libPaths = @(
          "$env:LIBSNDFILE_LIB",
          "$env:MUPARSERX_LIB",
          "$env:FFTW_LIB"
        )
        if ($env:LIB) {
          $env:LIB = ($libPaths + $env:LIB) -join ";"
        } else {
          $env:LIB = $libPaths -join ";"
        }
        Write-Host "  LIB (linker search path): $env:LIB"
        Write-Host ""

        $buildParams = @(
          "/m",
          "/p:Configuration=${{ env.BUILD_CONFIGURATION }}",
          "/p:Platform=${{ matrix.platform }}",
          "/t:rebuild",
          "/p:LIBSNDFILE_INCLUDE=$env:LIBSNDFILE_INCLUDE",
          "/p:LIBSNDFILE_LIB=$env:LIBSNDFILE_LIB",
          "/p:FFTW_INCLUDE=$env:FFTW_INCLUDE",
          "/p:FFTW_LIB=$env:FFTW_LIB",
          "/p:MUPARSERX_INCLUDE=$env:MUPARSERX_INCLUDE",
          "/p:MUPARSERX_LIB=$env:MUPARSERX_LIB",
          "/p:TCLAP_ROOT=$env:TCLAP_ROOT",
          "/p:PlatformToolset=v143"  # Override to VS 2022 toolset for CI (project uses v145/VS 2026)
        )

        $BuildPlatform = "${{ matrix.platform }}"
        # Only add instruction set override if specified (not for ARM64)
        if ($BuildPlatform -eq "x64") {
          # Set instruction set based on SIMD variant
          $instructionSet = if ("${{ matrix.simd_variant }}" -eq "avx512") {
            "AdvancedVectorExtensions512"
          } elseif ("${{ matrix.simd_variant }}" -eq "avx10_1") {
            "AdvancedVectorExtensions101"
          } else {
            "AdvancedVectorExtensions2"
          }
          Write-Host "Building with instruction set: $instructionSet (variant: ${{ matrix.simd_variant }})"
          $buildParams += "/p:EnableEnhancedInstructionSet=$instructionSet"
        }

        foreach ($project in $projects) {
          Write-Host "`n=== Building $project ==="
          Write-Host "MSBuild command: msbuild $project $($buildParams -join ' ')"
          msbuild $project @buildParams
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Build failed for $project"
            exit $LASTEXITCODE
          }
        }

      
    #
    # Configure MSVC
    #
    - name: Configure MSVC
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: ${{ matrix.msvcdevplatform }}

    # Build Qt projects with qmake (Editor, DeviceSelector, UpdateChecker)
    - name: Build Qt Applications
      shell: pwsh
      run: |
        # Find qmake from Qt installation
        $qmakePath = Get-Command qmake -ErrorAction SilentlyContinue
        if (-not $qmakePath) {
          $qmakePath = "$env:Qt6_DIR\bin\qmake.exe"
        }
        Write-Host "Using qmake: $qmakePath"

        $lreleasePath = Get-Command lrelease -ErrorAction SilentlyContinue
        if (-not $lreleasePath) {
          $lreleasePath = "$env:Qt6_DIR\bin\lrelease.exe"
        }
        Write-Host "Using lrelease: $lreleasePath"

        $windeployqtPath = Get-Command windeployqt -ErrorAction SilentlyContinue
        if (-not $windeployqtPath) {
          $windeployqtPath = "$env:Qt6_DIR\bin\windeployqt.exe"
        }
        Write-Host "Using windeployqt: $windeployqtPath"

        # Find build tool (jom or nmake)
        $jomPath = Get-Command jom -ErrorAction SilentlyContinue
        $buildTool = if ($jomPath) { "jom" } else { "nmake" }
        Write-Host "Using build tool: $buildTool"

        $BuildPlatform = "${{ matrix.platform }}"
        if ($BuildPlatform -eq "x64") {
          # Set compiler flags based on SIMD variant
          $simdFlags = switch ("${{ matrix.simd_variant }}") {
            "avx512" { "/arch:AVX512" }
            "avx10_1" { "/arch:AVX10.1" }
            "avx2" { "/arch:AVX2" }
          }
          if ($simdFlags) {
            Write-Host "Qt builds using SIMD flags: $simdFlags (variant: ${{ matrix.simd_variant }})"
          }
        }

        # Helper function to build a Qt project
        function Build-QtProject {
          param($projectName, $projectPath)

          Write-Host "`n=== Building $projectName ==="
          $buildDir = "build-$projectName-${{ matrix.platform }}"

          New-Item -ItemType Directory -Force -Path $buildDir | Out-Null
          Set-Location $buildDir


          & $lreleasePath ..\$projectPath
          # Remove /arch:AVX2 from .pro file and replace with our SIMD variant
          # This is done by removing the hardcoded /arch flag and adding our SIMD variant (if specified)
          if ($BuildPlatform -eq "x64") {
            & $qmakePath ..\$projectPath -r "CONFIG+=release" "QMAKE_CXXFLAGS-=/arch:AVX2" "QMAKE_CXXFLAGS+=$simdFlags"
          }
          else {
            & $qmakePath ..\$projectPath -r "CONFIG+=release"
          }
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "$projectName qmake failed"
            Set-Location ..
            return $false
          }

          & $buildTool
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "$projectName build failed"
            Set-Location ..
            return $false
          }

          # Deploy Qt dependencies (DLLs, plugins, etc.)
          Write-Host "Deploying Qt dependencies for $projectName..."
          $exePath = "release\$projectName.exe"
          if (Test-Path $exePath) {
            Write-Host "Running: $windeployqtPath $exePath --release --no-opengl-sw"
            & $windeployqtPath $exePath --release --no-opengl-sw
            if ($LASTEXITCODE -ne 0) {
              Write-Error "windeployqt failed for $projectName (exit code: $LASTEXITCODE)"
              Set-Location ..
              return $false
            }

            # Verify critical Qt files were deployed
            $requiredFiles = @("platforms\qwindows.dll")
            $missingFiles = @()
            foreach ($file in $requiredFiles) {
              $filePath = "release\$file"
              if (-not (Test-Path $filePath)) {
                $missingFiles += $file
              }
            }

            if ($missingFiles.Count -gt 0) {
              Write-Error "Critical Qt files missing after windeployqt: $($missingFiles -join ', ')"
              Set-Location ..
              return $false
            }

            Write-Host "Qt dependencies deployed successfully for $projectName"
          } else {
            Write-Error "Executable not found at $exePath"
            Set-Location ..
            return $false
          }

          Set-Location ..
          Write-Host "$projectName built successfully"
          return $true
        }

        # Build all Qt projects
        $editorSuccess = Build-QtProject "Editor" "Editor\Editor.pro"
        $deviceSelectorSuccess = Build-QtProject "DeviceSelector" "DeviceSelector\DeviceSelector.pro"
        $updateCheckerSuccess = Build-QtProject "UpdateChecker" "UpdateChecker\UpdateChecker.pro"

        # Check if any builds failed
        if (-not $editorSuccess) {
          Write-Error "Editor build failed"
          exit 1
        }
        if (-not $deviceSelectorSuccess) {
          Write-Error "DeviceSelector build failed"
          exit 1
        }
        if (-not $updateCheckerSuccess) {
          Write-Error "UpdateChecker build failed"
          exit 1
        }

        Write-Host "`nAll Qt applications built successfully!"

    # Package artifacts
    - name: Package binaries
      shell: pwsh
      run: |
        $platform = "${{ matrix.platform }}"
        $simdVariant = "${{ matrix.simd_variant }}"
        $artifactName = "EqualizerAPO-$platform-$simdVariant"
        $artifactPath = "${{ github.workspace }}\artifacts\$artifactName"

        New-Item -ItemType Directory -Force -Path $artifactPath | Out-Null

        # Determine output directory (all platforms use {Platform}/Release)
        $outDir = "$platform\Release"

        # Copy main binaries (required files)
        $requiredFiles = @(
          "EqualizerAPO\${{ matrix.platform }}\Release\EqualizerAPO.dll",
          "Benchmark\${{ matrix.platform }}\Release\Benchmark.exe",
          "VoicemeeterClient\${{ matrix.platform }}\Release\VoicemeeterClient.exe"
        )

        foreach ($file in $requiredFiles) {
          $sourcePath = "${{ github.workspace }}\$file"
          if (Test-Path $sourcePath) {
            Copy-Item $sourcePath -Destination $artifactPath
            Write-Host "Copied: $file"
          } else {
            Write-Error "Required file not found: $file"
            exit 1
          }
        }
        Copy-Item ${{ github.workspace }}\deps\fftw\Release\libfftw3.dll -Destination $artifactPath -Force
        Copy-Item ${{ github.workspace }}\deps\libsndfile\build\Release\sndfile.dll -Destination $artifactPath -Force

        # Copy Qt applications built with qmake (Editor, DeviceSelector, UpdateChecker)
        # Include all deployed Qt dependencies (DLLs, plugins, etc.)
        $qtApps = @("Editor", "DeviceSelector", "UpdateChecker")

        foreach ($appName in $qtApps) {
            $buildDir = "${{ github.workspace }}\build-$appName-$platform\release"
            $exePath = "$buildDir\$appName.exe"

            if (Test-Path $exePath) {
              # Copy the entire release directory to preserve Qt deployment structure
              # This includes the .exe, Qt DLLs, platforms/, styles/, etc.
              # BUT exclude build artifacts (.obj, .res, .log, etc.)
              Write-Host "Copying $appName with Qt dependencies..."

              # Get all items in the release directory, excluding build artifacts
              $excludeExtensions = @('.obj', '.res', '.log', '.tlog', '.iobj', '.ipdb', '.ilk', '.pdb')
              $items = Get-ChildItem -Path $buildDir -Recurse | Where-Object {
                # Exclude files with build artifact extensions
                if (-not $_.PSIsContainer) {
                  $extension = $_.Extension.ToLower()
                  return -not ($excludeExtensions -contains $extension)
                }
                return $true  # Include all directories
              }

              foreach ($item in $items) {
                $relativePath = $item.FullName.Substring($buildDir.Length + 1)
                $targetPath = Join-Path $artifactPath $relativePath

                if ($item.PSIsContainer) {
                  # Create directory
                  New-Item -ItemType Directory -Force -Path $targetPath | Out-Null
                } else {
                  # Copy file
                  $targetDir = Split-Path $targetPath -Parent
                  if (-not (Test-Path $targetDir)) {
                    New-Item -ItemType Directory -Force -Path $targetDir | Out-Null
                  }
                  Copy-Item -Path $item.FullName -Destination $targetPath -Force
                }
              }

              Write-Host "Copied: $appName with Qt dependencies (DLLs, plugins, excluding .obj files)"
            } else {
              Write-Host "$appName.exe not built (build may have failed)"
            }
        }

    # Upload artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: EqualizerAPO-${{ matrix.platform }}-${{ matrix.simd_variant }}
        path: |
          ${{ github.workspace }}\artifacts\EqualizerAPO-${{ matrix.platform }}-${{ matrix.simd_variant }}/*.dll
          ${{ github.workspace }}\artifacts\EqualizerAPO-${{ matrix.platform }}-${{ matrix.simd_variant }}/*.exe
          ${{ github.workspace }}\artifacts\EqualizerAPO-${{ matrix.platform }}-${{ matrix.simd_variant }}/iconengines/
          ${{ github.workspace }}\artifacts\EqualizerAPO-${{ matrix.platform }}-${{ matrix.simd_variant }}/imageformats/
          ${{ github.workspace }}\artifacts\EqualizerAPO-${{ matrix.platform }}-${{ matrix.simd_variant }}/platforms/
          ${{ github.workspace }}\artifacts\EqualizerAPO-${{ matrix.platform }}-${{ matrix.simd_variant }}/styles/
          ${{ github.workspace }}\artifacts\EqualizerAPO-${{ matrix.platform }}-${{ matrix.simd_variant }}/tls/
        if-no-files-found: error
        retention-days: 90

  # Create installer (runs after all platforms are built)
  create-installer:
    needs: build
    runs-on: windows-2025
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        include:
          - platform: x64
            simd_variant: avx2
            setup_file: Setup64
            installer_name: x64-avx2
          - platform: x64
            simd_variant: avx512
            setup_file: Setup64
            installer_name: x64-avx512
          - platform: x64
            simd_variant: avx10_1
            setup_file: Setup64
            installer_name: x64-avx10_1
          - platform: ARM64
            simd_variant: neon
            setup_file: SetupARM64
            installer_name: arm64

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ${{ github.workspace }}\artifacts

    - name: Prepare installer files
      shell: pwsh
      run: |
        # Copy binaries to expected locations for NSIS
        # NSIS expects:
        # - Project binaries (.exe, EqualizerAPO.dll) in Platform\Release\
        # - Dependencies (Qt DLLs, libfftw3.dll, sndfile.dll, etc.) in lib64\

        $simdVariant = "${{ matrix.simd_variant }}"
        $artifactDir = "${{ github.workspace }}\artifacts\EqualizerAPO-${{ matrix.platform }}-$simdVariant"
        $targetBinDir = "${{ github.workspace }}\${{ matrix.platform }}\Release"
        $targetLibDir = "${{ github.workspace }}\lib64"

        if (Test-Path $artifactDir) {
          New-Item -ItemType Directory -Force -Path $targetBinDir | Out-Null
          New-Item -ItemType Directory -Force -Path $targetLibDir | Out-Null

          # Copy project binaries to Platform\Release
          $projectBinaries = @(
            "EqualizerAPO.dll",
            "Benchmark.exe",
            "VoicemeeterClient.exe",
            "DeviceSelector.exe",
            "UpdateChecker.exe",
            "Editor.exe"
          )

          foreach ($file in $projectBinaries) {
            $sourcePath = Join-Path $artifactDir $file
            if (Test-Path $sourcePath) {
              Copy-Item $sourcePath -Destination $targetBinDir -Force
              Write-Host "Copied to binaries: $file"
            } else {
              Write-Warning "Project binary not found: $file"
            }
          }

          # Copy all dependency DLLs and Qt folders to lib64
          # Qt folders are grouped under lib64\qt\<folder>\...
          $qtFolders = @('platforms', 'styles', 'iconengines', 'imageformats', 'tls')
          $qtTargetDir = Join-Path $targetLibDir 'qt'
          New-Item -ItemType Directory -Force -Path $qtTargetDir | Out-Null

          Get-ChildItem -Path $artifactDir | ForEach-Object {
            $name = $_.Name

            # Skip project binaries (already copied above)
            if ($projectBinaries -contains $name) {
              return
            }

            if ($_.PSIsContainer -and $qtFolders -contains $name) {
              # Qt runtime folder -> lib64\qt\<name>\... (preserve subfolders & DLLs)
              $dest = Join-Path $qtTargetDir $name
              Copy-Item -Path $_.FullName -Destination $dest -Recurse -Force
              Write-Host "Copied Qt folder to lib64\qt: $name\"
            }
            elseif ($_.PSIsContainer) {
              # Non-Qt directories (if any) still go at lib64 root
              Copy-Item -Path $_.FullName -Destination $targetLibDir -Recurse -Force
              Write-Host "Copied non-Qt folder to lib64: $name\"
            }
            else {
              # Individual files (DLLs, etc.) go in lib64 root
              Copy-Item -Path $_.FullName -Destination $targetLibDir -Force
              Write-Host "Copied to lib64: $name"
            }
          }
          Write-Host "`nArtifacts organized for NSIS installer:"
          Write-Host "  Binaries: $targetBinDir"
          Write-Host "  Dependencies: $targetLibDir"
        } else {
          Write-Error "Artifact directory not found: $artifactDir"
          exit 1
        }

    - name: Install NSIS
      uses: negrutiu/nsis-install@v2

    - name: Install `NsArray` from web
      uses: negrutiu/nsis-install-plugin@v1
      with:
        url: https://nsis.sourceforge.io/mediawiki/images/9/97/NsArray.zip

    - name: Install `NSISpcre` from web
      uses: negrutiu/nsis-install-plugin@v1
      with:
        url: https://github.com/mazinsw/NSISpcre/archive/refs/heads/master.zip
    - name: Install `AccessControl` from web
      uses: negrutiu/nsis-install-plugin@v1
      with:
        url: https://nsis.sourceforge.io/mediawiki/images/4/4a/AccessControl.zip
    - name: Build installer
      run: makensis ${{ github.workspace }}\Setup\${{ matrix.setup_file }}.nsi

    - name: Upload installers
      uses: actions/upload-artifact@v4
      with:
        name: EqualizerAPO_Setup-${{ matrix.installer_name }}
        path: ${{ github.workspace }}\Setup\*.exe
        if-no-files-found: warn
        retention-days: 90
